#include "kpgrid.h"

void helper()
{
    fprintf(stderr," (MSL coreutils) \"%s\" v. %s (%s)\n",EXE,VERS,__DATE__);
    fprintf(stderr," Utility to compute the divisions for a k-point grid\n");
    fprintf(stderr," and write a KPOINTS file to be used by VASP\n");
    fprintf(stderr,"   ** File name assumed to be last argument...\n\n");
    fprintf(stderr," Usage: kpgrid  [OPTIONS] file > KPOINTS\n");    
    fprintf(stderr," options...\n");
    fprintf(stderr,"     -c|--compress     compress lattice vectors, in (%%)\n");
    fprintf(stderr,"                       default == no compression.\n");
    fprintf(stderr,"                       negative value expands the cell\n");
    fprintf(stderr,"     -d|--density      density of the kpoint mesh, in Å^-1 \n");
    fprintf(stderr,"                       default == 0.03 Å^-1 .\n");
    fprintf(stderr,"     -m|--monk         print the KPOINTS file for a \n");
    fprintf(stderr,"                       Monkhorst-Pack style grid.\n");
    fprintf(stderr,"                       default == gamma centered\n");
    fprintf(stderr," extras...\n");
    fprintf(stderr,"    -h|--help          this message\n");
    fprintf(stderr,"    -v|--version       show author and version info\n");
    fprintf(stderr,"    -u|--usage         brief list of parameters and arguments\n\n");
    fprintf(stderr," examples....\n");
    fprintf(stderr,"    %s CONTCAR > KPOINTS\n",EXE);
    fprintf(stderr,"    %s --density 0.05 -mc 50 POSCAR > KPOINTS\n",EXE);
    fprintf(stderr,"    %s -c 40 --monk -d 0.02 sns2.2x2x1.poscar > KPOINTS\n",EXE);
    exit(EXIT_FAILURE);
}


void show_version()
{
    fprintf(stdout," (MSL coreutils) %s v. %s\n",EXE,VERS );
    fprintf(stdout," Copyright (C) 2016 Materials Simulation Laboratory\n" );
    fprintf(stdout," This is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n" );
    fprintf(stdout," Written by: Joseph M. Gonzalez\n");
    exit(EXIT_SUCCESS);
}


void usage()
{
    fprintf(stdout," (MSL coreutils) %s v. %s\n",EXE,VERS );
    fprintf(stdout," USAGE: %s [OPTIONS] filename > KPOINTS\n",EXE );
    fprintf(stdout," OPTIONS: [-c compress cell] [-d kpt density] \n" );
    fprintf(stdout,"          [-m Monkhorst grid] [-h help] \n" );
    fprintf(stdout,"          [-v version info]\n" );
    exit(EXIT_SUCCESS);
}

int main(int nargs, char** argv)
{

    // default kspacing in Å^-1
    double dk = 0.03;
    
    // calculated divisions for k-point mesh
    int    nx=1,ny=1,nz=1;

    // dont apply a compression by default
    double compRatio =0;
    int    compCell = 0; 

    // assume the user wants a Gamma centered grid
    int    gamma = 1;

    // POSCAR/CONTCAR
    char*  inFile = NULL;

    if (nargs==1) helper();

    for (int ii = 1; ii < nargs; ii++) {
        if (argv[ii][0]=='-' && argv[ii][1]!='-' ) {
            char* option =argv[ii];
            for (int l=1;l<strlen(option);l++) {
                if (option[l]=='h') helper();
                else if (option[l]=='c') {compCell;compRatio = atof(argv[ii+1]);}
                else if (option[l]=='d') dk = atof(argv[ii+1]);
                else if (option[l]=='m') gamma =0;
                else if (option[l]=='u') usage( );
                else if (option[l]=='v') show_version( );
            }
        } 
        else if (argv[ii][0]=='-' && argv[ii][1]=='-') {
            argv[ii]++;argv[ii]++; // skip over the --
            if (strcmp(argv[ii],"help")==0) helper();
            else if (strcmp(argv[ii],"compress")==0) {compCell;compRatio = atof(argv[ii+1]);}
            else if (strcmp(argv[ii],"density")==0) dk = atof(argv[ii+1]);
            else if (strcmp(argv[ii],"monk")==0) gamma =0;
            else if (strcmp(argv[ii],"usage")==0) usage();
            else if (strcmp(argv[ii],"version")==0) show_version();
        }
    }


    // grab the file, assumed to be the last argument....
    inFile = argv[nargs-1];

    // read the file and store the lattice vectors
    double** H = read_box( inFile );

    // compute the compressed lattice vectors scale
    double scale = 1.-(compRatio/100.);

    // compress the lattice if needed
    if (compCell) compress_vectors( scale,H );

    // compute the reciprocal lattice vectors
    double** G = recp_vectors( H );

    // compute the grid using a custom spacing
    compute_grid( dk,G,&nx,&ny,&nz );

    // print the new file to stdout
    printf("Kpoints generated by `%s`\n",EXE);
    printf("0\n");
    if (gamma) printf("Gamma\n");
    else printf("Monkhorst\n");
    printf("%i %i %i\n",nx,ny,nz);
    printf("0 0 0\n");

    fprintf(stderr,"Kpoints mesh generated using a spacing of [%3.3f] Å^-1\n", dk);
    fprintf(stderr,"nx = %i | ny = %i | nz = %i\n",nx,ny,nz );
    

    return 0;
}

double** read_box( char* fname)
{
    std::ifstream input(fname);
    if (!input.is_open()) {
        fprintf(stderr,"Error: Could not open the file [%s] for reading ... \n",fname);
        exit(1);
    }

    double** H = new double*[3];
    for (int i=0;i<3;i++) H[i] = new double[3];

    std::string arg1,arg2,arg3;
    std::string line;
    std::istringstream iss;
    double scale = 0;

    // comment line
    std::getline(input,line);
    iss.clear();iss.str(line);
    iss >> arg1;

    // scaling parameter
    std::getline(input,line);
    iss.clear();iss.str(line);
    iss >> arg1;
    scale = str2num<double>(arg1);

    // lattice vectors
    std::getline(input,line);
    iss.clear();iss.str(line);
    iss >> arg1 >> arg2 >> arg3;
    H[0][0] = str2num<double>(arg1)*scale;
    H[0][1] = str2num<double>(arg2)*scale;
    H[0][2] = str2num<double>(arg3)*scale;

    std::getline(input,line);
    iss.clear();iss.str(line);
    iss >> arg1 >> arg2 >> arg3;
    H[1][0] = str2num<double>(arg1)*scale;
    H[1][1] = str2num<double>(arg2)*scale;
    H[1][2] = str2num<double>(arg3)*scale;

    std::getline(input,line);
    iss.clear();iss.str(line);
    iss >> arg1 >> arg2 >> arg3;
    H[2][0] = str2num<double>(arg1)*scale;
    H[2][1] = str2num<double>(arg2)*scale;
    H[2][2] = str2num<double>(arg3)*scale;

    return H;
}

double** recp_vectors(double** H)
{
    double volume = 0;
    double** G = new double*[3];
    for (int i=0;i<3;i++) G[i] = new double[3];

    double* crossed = vcross(H[1],H[2]);
    volume = vdot(H[0],crossed);
    G[0][0] = crossed[0]/volume;
    G[0][1] = crossed[1]/volume;
    G[0][2] = crossed[2]/volume;


    crossed = vcross(H[2],H[0]);
    volume = vdot(H[1],crossed);
    G[1][0] = crossed[0]/volume;
    G[1][1] = crossed[1]/volume;
    G[1][2] = crossed[2]/volume;

    crossed = vcross(H[0],H[1]);
    volume = vdot(H[2],crossed);
    G[2][0] = crossed[0]/volume;
    G[2][1] = crossed[1]/volume;
    G[2][2] = crossed[2]/volume;

    return G;
}

void compress_vectors(double scale, double** H)
{
    for (int i=0;i<3;i++) {
        H[0][i] *= cbrt(scale);
        H[1][i] *= cbrt(scale);
        H[2][i] *= cbrt(scale);
    }
}

void compute_grid(double dk, double** G, int* nx, int* ny, int* nz)
{
    *nx = ceil( vmag(G[0])/dk );
    *ny = ceil( vmag(G[1])/dk );
    *nz = ceil( vmag(G[2])/dk );
}


double vmag(double* a)
{
    double sum=0;
    double mag = 0;
    for(int ii=0; ii<3; ii++) sum += a[ii]*a[ii]; 
    mag = sqrt( sum );
    return mag;
}

double vdot(double* a, double* b) 
{
    double sum=0;
    for(int ii=0; ii<3; ii++) 
        sum += a[ii]*b[ii]; 
    return sum;
}


double angle(double* a, double* b)
{
    double am = vmag( a );
    double bm = vmag( b );
    double dot = vdot( a,b );
    double res = acos(dot/(am*bm));
    return res;
}

double* vcross(double* a,double* b)
{
    double* crossed = new double[3];
    crossed[0] = a[1]*b[2] - a[2]*b[1];
    crossed[1] = a[2]*b[0] - a[0]*b[2];
    crossed[2] = a[0]*b[1] - a[1]*b[0];
    return crossed;
}